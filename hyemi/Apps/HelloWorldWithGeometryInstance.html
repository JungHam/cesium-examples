<!DOCTYPE html>
<html lang="en">

<head>
  <!-- Use correct character set. -->
  <meta charset="utf-8">
  <!-- Tell IE to use the latest, best version. -->
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <!-- Make the application on mobile take up the full browser screen and disable user scaling. -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  <title>Hello World!</title>
  <script src="../Build/Cesium/Cesium.js"></script>
  <script src='../js/libs/papaparse.min.js' type='text/javascript'></script>

  <script src="../js/loader/IndoorGMLLoader.js"></script>
  <script src='../js/libs/jquery-1.8.0.min.js' type='text/javascript'></script>
  <script type="text/javascript" src="Sandcastle/Sandcastle-header.js"></script>
  <script src="../js/viewer.js"></script>
  <script src="https://ajax.googleapis.com/ajax/libs/angularjs/1.6.1/angular.min.js"></script>
  <script scr="calculate_surface.js"></script>
  <style>
  @import url(Sandcastle/templates/bucket.css);
  #toolbar {
    background: rgba(42, 42, 42, 0.8);
    padding: 2px;
    border-radius: 4px;
  }

  #toolbar input {
    vertical-align: middle;
    padding-top: 2px;
    padding-bottom: 2px;
  }
  </style>
</head>

<body>
  <div id="cesiumContainer" class="fullSize"></div>
  <div id="toolbar">
    <input id="polygon_typhoon2015" type="button" onclick="polygon_typhoon(this)" value="polygon_typhoon2015"></input>
    <input id="polygon_typhoon2016" type="button" onclick="polygon_typhoon(this)" value="polygon_typhoon2016"></input>
    <input id="point_typhoon" type="button" onclick="point_typhoon()" value="point_typhoon"></input>
    <div id="toolbar_point"></div>
    <div id="toolbar_polygon"></div>
    <div id="toolbar_polygon2"></div>
    <input id= "button_triangle" type = "button" onclick = "getSurface('example.json')" value="print linestrings surfaces"></input>
    <input id= "button_triangle_moving" type = "button" onclick = "getMovingUnsamePolygon('example.json')" value="print linestrings moving"></input>

  </div>
  <script type="text/javascript">

  var viewer = new Cesium.Viewer('cesiumContainer');
  var moving_id;
  //viewer.scene.mode = Cesium.SceneMode.COLUMBUS_VIEW;

  //console.log(sceneModePicker);
  //console.log(scene.morphComplete);
  var hur_data = Cesium.GeoJsonDataSource.load('hurricane.json');
  var scene = viewer.scene;

  var line_list = new Array();
  var lines;

  var gl_data;
  var time_list = [];
  var point_list = [];
  var line_time_list = [];
  var height = [];
  var coordinates = [];
  var currSec = 60 * 60 * 1000;
  var change_shape;
  var selected = new Array();
  var selected_poly = new Array();
  var selected_poly = new Array();
  var moving_path;
  var selected_radio = new Array();
  var selected_poly_radio = new Array();
  var gl_p_data_2016 = new Array();
  var gl_p_data_2015 = new Array();
  var p_ty_2015 = new Array();
  var p_ty_2016 = new Array();
  var name_list = [];
  var name_list_2016 = new Array();
  var name_list_2015 = new Array();
  var point_typhoon_button = false;

  var polygon_typhoon_button = false;
  var polygon_typhoon_button2 = false;

  var maked_instances = new Array();
  var typhoon_2016 = new Cesium.PrimitiveCollection();
  var typhoon_2015 = new Cesium.PrimitiveCollection();

  scene.morphComplete.addEventListener(function() {
    changeMode();
    scene.completeMorph();
  });

  function point_typhoon() {
    var line_time_list = [];
    var name_list = [];
    if (point_typhoon_button == true) {
      point_typhoon_button = false;
      var label_list = "";

      document.getElementById("toolbar_point").innerHTML = label_list;
      lines.removeAll(); //delete all the lines on the map
    } else {
      point_typhoon_button = true;
      $.getJSON("hurricane.json", function(data) {
        gl_data = data;
        lines = new Cesium.PolylineCollection(); //make PolylineCollection for containing several polylines.

        for (var i in data) {
          line_list = [];
          line_time_list = [];
          point_list = [];

          line_list = data[i].temporalGeometry.coordinates;
          line_time_list = data[i].temporalGeometry.datetimes;
          name_list[i] = data[i].properties.name;

          //make array for setting one polylines.
          var base_time = data[i].temporalGeometry.datetimes[0]; //the basetime we will use for nomalization of datetimes

          base_time = getTime(base_time);


          for (var j in line_list) {
            point_list[2 * j] = line_list[j][1];
            point_list[2 * j + 1] = line_list[j][0];

          }

          lines.add({ //add a set of points of polyline at PolylineCollection.
            id: i,
            positions: Cesium.Cartesian3.fromDegreesArray(point_list), //add points as array
            color: Cesium.Color.WHITE,
            width: 2
          });
        }

        //console.log(transitioner);
        var label_list = "";
        for (var k in name_list) {
          label_list += "<label style = 'color:white' onclick = 'changeColor(";
          label_list += k;
          label_list += ")'>";
          label_list += name_list[k];
          label_list += "</label>";
          label_list += "<input type = 'checkbox' onclick = 'getMoving(";
          label_list += k;
          label_list += ")'></input></br>";
        }

        document.getElementById("toolbar_point").innerHTML = label_list;
        //console.log(lines);
        viewer.scene.primitives.add(lines);
        //primitives is a geometry in Cesium.
        //So just add polylines as one geometry at Cesium viewer.
        //You need to check primitives and geometryInstance for Cesium.
        //console.log(point_list);
      });
    }
  }
  function printNames(filename, label_id){
    var label_list = "";
    window.name_list = [];
    $.getJSON(filename, function(data) {
      for(var i = 0 ; i < data.features.length ; i++){
        window.name_list.push(data.features[i].properties.name);
      }
      for (var k = 0 ; k < window.name_list.length ; k++ ) {
        label_list += "<label style = 'color:white' onclick = 'changeColor_poly(";
        label_list += k;
        label_list += ",";
        label_list += "\"";
        label_list += filename;
        label_list += "\"";
        label_list += ")'>";
        label_list += name_list[k];
        label_list += "</label>";
        label_list += "<input type = 'checkbox' onclick = 'getMovingPolygon(";
        label_list += k;
        label_list += ",";
        label_list += "\"";
        label_list += filename;
        label_list += "\"";
        label_list += ")'></input></br>";
      }

      document.getElementById(label_id.toString()).innerHTML = label_list;
    });

  }
function changeColor_poly(buttonNumber,filename){

  var id = filename.toString();
  id = filename.split(".");
  id = id[0] + buttonNumber.toString();
  if(scene.mode == Cesium.SceneMode.COLUMBUS_VIEW){
    if(contains(selected_poly,id)){

      var already_selected = selected_poly.indexOf(id);
      selected_poly.splice(already_selected, 1);
      //console.log(selected_poly);
      var typhoon;
      if(filename == "typhoon2015_buffer.json"){
        typhoon = typhoon_2015;
      }
      else{
        typhoon = typhoon_2016;
      }

      for(var i = 0 ; i < typhoon.length ; i++){
        var temp = typhoon.get(i);
        temp.show = true;
      }

      //change color as original one
    }
    else{
      //console.log(selected_poly);
      selected_poly.push(id);
      $.getJSON(filename, function(data) {
        var typhoon;
        if(filename == "typhoon2015_buffer.json"){
          typhoon = typhoon_2015;
        }
        else{
          typhoon = typhoon_2016;
        }


          var target = typhoon.get(buttonNumber);
          for(var i = 0 ; i < typhoon.length ; i++){
            var temp = typhoon.get(i);
            temp.show = false;
          }
          target.show = true;

      });
    }

  }
}


function getNames(filename){
      window.name_list = [];
      $.getJSON(filename, function(data) {
        for(var i = 0 ; i < data.features.length ; i++){
          window.name_list.push(data.features[i].properties.name);
        }

      });
      console.log(window.name_list.length);

  }

  function polygon_typhoon(callvalue) {
    if(callvalue.value == "polygon_typhoon2015"){
      if (polygon_typhoon_button == true) {
        var label_list = "";
        document.getElementById("toolbar_polygon").innerHTML = label_list;
        polygon_typhoon_button = false;
        typhoon_2015.show = false;
      } else if(polygon_typhoon_button == false && contains(maked_instances,typhoon_2015)){

        polygon_typhoon_button = true;
        typhoon_2015.show = true;
        printNames("typhoon2015_buffer.json","toolbar_polygon");
      }
      else{

        polygon_typhoon_button = true;
        drawPolygon("typhoon2015_buffer.json", "toolbar_polygon", typhoon_2015);
        maked_instances.push(typhoon_2015);
      }
    }
    else if (callvalue.value == "polygon_typhoon2016"){
      if (polygon_typhoon_button2 == true) {
        var label_list = "";
        document.getElementById("toolbar_polygon2").innerHTML = label_list;
        polygon_typhoon_button2 = false;
        typhoon_2016.show = false;
      } else if(polygon_typhoon_button2 == false &&  contains(maked_instances,typhoon_2016)){
        printNames("typhoon2016_buffer.json","toolbar_polygon2");
        polygon_typhoon_button2 = true;
        typhoon_2016.show = true;
      }
      else{
        polygon_typhoon_button2 = true;
        drawPolygon("typhoon2016_buffer.json", "toolbar_polygon2", typhoon_2016);
        maked_instances.push(typhoon_2016);
      }
    }
  }

  function getMoving(radioItem) {
  if (selected_radio.length != 0) {
      if (!contains(selected_radio, radioItem)) {

      } else if (contains(selected_radio, radioItem) && contains(selected, radioItem)) {
        viewer.entities.remove(viewer.entities.getById(moving_id));
        var already_selected = selected_radio.indexOf(radioItem);
        setDefaultClock();
      }
    } else if (contains(selected, radioItem) && !contains(selected_radio, radioItem)) {

      selected_radio.push(radioItem);
      var moving_item = gl_data[radioItem].temporalGeometry;
      var start = Cesium.JulianDate.fromDate(getTime(moving_item.datetimes[0]));
      var stop = Cesium.JulianDate.fromDate(getTime(moving_item.datetimes[moving_item.datetimes.length - 1]));

      viewer.clock.startTime = start.clone();
      viewer.clock.stopTime = stop.clone();
      viewer.clock.currentTime = start.clone();
      viewer.clock.multiplier = 6000;
      viewer.timeline.zoomTo(start, stop);

      var position = new Array();
      var property = new Cesium.SampledPositionProperty();

      if (scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {
        var time = moving_item.datetimes[0];
        time = getTime(time);
        for (var j in moving_item.coordinates) {
          position[3 * j] = moving_item.coordinates[j][1];
          position[3 * j + 1] = moving_item.coordinates[j][0];
        }
        for (var k in moving_item.datetimes) {
          position[3 * k + 2] = parseInt((getTime(moving_item.datetimes[k]) - time) / currSec) * 6000;
        }
        for (var i = 0; i < moving_item.coordinates.length; i++) {
          var temp_position = Cesium.Cartesian3.fromDegrees(position[3 * i], position[3 * i + 1], position[3 * i + 2]);
          var temp_time = Cesium.JulianDate.fromDate(getTime(moving_item.datetimes[i]));
          property.addSample(temp_time, temp_position);
        }

      } else {

        var time = moving_item.datetimes[0];
        time = getTime(time);

        for (var j in moving_item.coordinates) {
          position[2 * j] = moving_item.coordinates[j][1];
          position[2 * j + 1] = moving_item.coordinates[j][0];
        }
        for (var i = 0; i < moving_item.coordinates.length; i++) {

          var temp_position = Cesium.Cartesian3.fromDegrees(position[2 * i], position[2 * i + 1]);
          var temp_time = Cesium.JulianDate.fromDate(getTime(moving_item.datetimes[i]));
          property.addSample(temp_time, temp_position);

        }
      }
      moving_id = radioItem.toString();
      moving_id += "_";
      moving_id += "radioItem";

      moving_path = viewer.entities.add({
        id: moving_id,
        availability: new Cesium.TimeIntervalCollection([new Cesium.TimeInterval({
          start: start,
          stop: stop
        })]),
        position: property,
        orientation: new Cesium.VelocityOrientationProperty(property),
        model: {
          uri: 'Cesium_Air.gltf',
          minimumPixelSize: 100
        }
      });

    }
  }

  function changeMode() { //add to eventlistener for change entitiy
    var change_line_list = [];

    if (scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {
      viewer.entities.add({
        id: 'time_axis',

        polyline: {
          positions: Cesium.Cartesian3.fromDegreesArrayHeights([180, 180, 1,  180, 180, 10000000]),
          width: 8,

          material: new Cesium.PolylineOutlineMaterialProperty({
            color: Cesium.Color.RED,
            outlineWidth: 2,
            outlineColor: Cesium.Color.BLACK
          }),

        }
      });
      viewer.entities.add({
        id : 'time_axis_label',
        position: Cesium.Cartesian3.fromDegrees(180, 180, 10000000),
        label: {
          text: 'TIME',
          font: '30px'
        },

      });


      if (point_typhoon_button == true) {
        var label_list = "";

        document.getElementById("toolbar_point").innerHTML = label_list;
        for (var i in gl_data) {
          var time = gl_data[i].temporalGeometry.datetimes[0];
          time = getTime(time);
          change_line_list = new Array();
          for (var j in gl_data[i].temporalGeometry.coordinates) {
            change_line_list[3 * j] = gl_data[i].temporalGeometry.coordinates[j][1];
            change_line_list[3 * j + 1] = gl_data[i].temporalGeometry.coordinates[j][0];
          }

          for (var k in gl_data[i].temporalGeometry.datetimes) {
            change_line_list[3 * k + 2] = parseInt((getTime(gl_data[i].temporalGeometry.datetimes[k]) - time) / currSec) * 6000;
          }
          lines.add({ //add a set of points of polyline at PolylineCollection.
            id: i,
            positions: Cesium.Cartesian3.fromDegreesArrayHeights(change_line_list), //add points as array
            color: Cesium.Color.WHITE,
            width: 2
          });
        }
      } else if (polygon_typhoon_button == true) {
        poly_change_COL("typhoon2015_buffer.json", typhoon_2015);
        if (polygon_typhoon_button2 == true) {
          poly_change_COL("typhoon2016_buffer.json",typhoon_2016);
        }
      }
      else if (polygon_typhoon_button2 == true) {
        poly_change_COL("typhoon2016_buffer.json",typhoon_2016);
        if (polygon_typhoon_button == true) {
          poly_change_COL("typhoon2015_buffer.json",typhoon_2016);
        }
      }


    } else { //not COLUMBUS_VIEW
      viewer.entities.remove(viewer.entities.getById('time_axis'));
      viewer.entities.remove(viewer.entities.getById('time_axis_label'));
      if (point_typhoon_button == true) {

        for (var i in gl_data) {
          var time = gl_data[i].temporalGeometry.datetimes[0];
          time = getTime(time);
          change_line_list = [];
          for (var j in gl_data[i].temporalGeometry.coordinates) {
            change_line_list[2 * j] = gl_data[i].temporalGeometry.coordinates[j][1];
            change_line_list[2 * j + 1] = gl_data[i].temporalGeometry.coordinates[j][0];

          }
          var change = lines.get(i);

          lines.add({ //add a set of points of polyline at PolylineCollection.
            id: i,
            positions: Cesium.Cartesian3.fromDegreesArray(change_line_list), //add points as array
            color: Cesium.Color.WHITE,
            width: 2
          });
        }
      } else if (polygon_typhoon_button == true) {
        poly_change("typhoon2015_buffer.json", typhoon_2015);
      }
      else if (polygon_typhoon_button2 == true) {
        poly_change("typhoon2016_buffer.json", typhoon_2016);
      }
    }
  }

  function getTime(timeValue) {
    var time = timeValue; //the basetime we will use for nomalization of datetimes
    var time_split = time.split('T'); //get date
    time_split[1] = time_split[1].replace('Z', ""); //get time
    var date_arr = time_split[0].split('-');
    var time_arr = time_split[1].split(':');
    var timestamp = new Date(date_arr[0], date_arr[1] - 1, date_arr[2], time_arr[0], time_arr[1], time_arr[2]);
    return timestamp;
  }

  var cor_list = [];

  var polyline;

  function contains(a, obj) {
    var i = a.length;
    while (i--) {
      if (a[i] === obj) {
        return true;
      }
    }
    return false;
  }

  function changeColor(labelValue) {

    var id_l;
    if (contains(selected, labelValue)) { //already existed item, then we removed highlight.
      //delete labelValue at Array.selected
      var already_selected = selected.indexOf(labelValue);
      selected.splice(already_selected, 1);
      //console.log(selected);
      for (var k in gl_data[labelValue].temporalGeometry.datetimes) {

        id_l = k.toString();
        id_l += '_l_';
        id_l += gl_data[labelValue].properties.name;

        viewer.entities.remove(viewer.entities.getById(id_l));

        //console.log(id_l);
      }
      polyline = lines.get(labelValue);
      polyline.material.uniforms.color = Cesium.Color.WHITE;
      viewer.trackedEntity = undefined;
    } else {
      selected.push(labelValue);
      //cor_list = [];
      change_shape = labelValue;
      polyline = lines.get(change_shape);
      var time = gl_data[change_shape].temporalGeometry.datetimes[0];
      //console.log (labelValue);
      polyline = lines.get(change_shape); //get is search polyline by index which is number.



      if (scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {
        //get the coordinates of polyline
        for (var j in gl_data[change_shape].temporalGeometry.coordinates) {

          cor_list[3 * j] = gl_data[change_shape].temporalGeometry.coordinates[j][1];
          cor_list[3 * j + 1] = gl_data[change_shape].temporalGeometry.coordinates[j][0];

        }
        //get the timestamps of polyline
        time = getTime(time);
        for (var j in gl_data[change_shape].temporalGeometry.datetimes) {
          cor_list[3 * j + 2] = parseInt((getTime(gl_data[change_shape].temporalGeometry.datetimes[j]) - time) / currSec) * 6000;
          time_list[j] = gl_data[change_shape].temporalGeometry.datetimes[j];
        }

        for (var k in gl_data[change_shape].temporalGeometry.datetimes) {
          var id_l = k.toString();
          id_l += '_l_';
          id_l += gl_data[change_shape].properties.name;
          viewer.entities.add({
            id: id_l,
            position: Cesium.Cartesian3.fromDegrees(cor_list[3 * k], cor_list[3 * k + 1], cor_list[3 * k + 2]),
            label: {
              text: time_list[k],
              font: '10px'
            }
          });

        }

        polyline.material.uniforms.color = Cesium.Color.HOTPINK; //polyline.material has attributes related to poly_option
        viewer.trackedEntity = polyline;

      } else {
        for (var j in gl_data[change_shape].temporalGeometry.coordinates) {

          cor_list[2 * j] = gl_data[change_shape].temporalGeometry.coordinates[j][1];
          cor_list[2 * j + 1] = gl_data[change_shape].temporalGeometry.coordinates[j][0];

        }
        for (var j in gl_data[change_shape].temporalGeometry.datetimes) {
          time_list[j] = gl_data[change_shape].temporalGeometry.datetimes[j];
        }
        //get the timestamps of polyline
        for (var k in gl_data[change_shape].temporalGeometry.datetimes) {
          //console.log(k);
          var id_l = k.toString();
          id_l += '_l_';
          id_l += gl_data[change_shape].properties.name;
          //  console.log(id_l);
          viewer.entities.add({
            id: id_l,
            position: Cesium.Cartesian3.fromDegrees(cor_list[2 * k], cor_list[2 * k + 1]),
            label: {
              text: time_list[k],
              font: '10px'
            }
          });

        }
        polyline.material.uniforms.color = Cesium.Color.HOTPINK; //polyline.material has attributes related to poly_option
        viewer.trackedEntity = polyline;

      }
    }
  }

  function drawPolygon(filename,label_id,typhoonCollection) {
    var one_ty;
    var new_line;
    var new_point;
    var name_list = [];
    var p_ty = new Array();

    $.getJSON(filename, function(p_data) {
      gl_p_data = p_data;
      for (var i = 0; i < gl_p_data.features.length; i++) {
        name_list.push(gl_p_data.features[i].properties.name);
      }
      var label_list = "";
      for (var k = 0 ; k < name_list.length ; k++ ) {
        label_list += "<label style = 'color:white' onclick = 'changeColor_poly(";
        label_list += k;
        label_list += ",";
        label_list += "\"";
        label_list += filename;
        label_list += "\"";
        label_list += ")'>";
        label_list += name_list[k];
        label_list += "</label>";
        label_list += "<input type = 'checkbox' onclick = 'getMovingPolygon(";
        label_list += k;
        label_list += ",";
        label_list += "\"";
        label_list += filename;
        label_list += "\"";
        label_list += ")'></input></br>";

      }

      document.getElementById(label_id.toString()).innerHTML = label_list;

      if (scene.mode == Cesium.SceneMode.COLUMBUS_VIEW) {

        for (var i = 0; i < gl_p_data.features.length; i++) {
          one_ty = new Array();
          var p_geo = gl_p_data.features[i].temporalGeometry; //one typhoon
          var base = p_geo.datetimes[0].split(" ");
          var base_J = Cesium.JulianDate.fromIso8601(base[0] + "T" + base[1] + "Z");
          for (var k = 0; k < 9; k++) { //lines
            new_line = new Array();
            for (var j = 0; j < p_geo.coordinates.length; j++) {
              new_point = new Array();
              var temp_time = p_geo.datetimes[j].split(" ");
              var temp_time_J = Cesium.JulianDate.fromIso8601(temp_time[0] + "T" + temp_time[1] + "Z");

              new_point.push(p_geo.coordinates[j][k][0]);
              new_point.push(p_geo.coordinates[j][k][1]);
              new_point.push(Cesium.JulianDate.secondsDifference(temp_time_J, base_J) * 3);

              new_line.push(new_point);
            }
            one_ty.push(new_line);
          }
          p_ty.push(one_ty);
        }

        var poly_list;
        var typhoon_poly;
        for (var i = 0; i < name_list.length; i++) { // one typ
          poly_list = new Array();
          for (var j = 0; j < 8; j++) { //line searching with 2

            for (var k = 0; k < p_ty[i][j].length - 1; k++) {
              var temp_poly = new Array();
              var first = p_ty[i][j][k];
              var sec = p_ty[i][j + 1][k];
              var third = p_ty[i][j + 1][k + 1];
              var forth = p_ty[i][j][k + 1];
              temp_poly.push(first[0], first[1], first[2], sec[0], sec[1], sec[2], third[0], third[1], third[2], forth[0], forth[1], forth[2]);
              var temp_instance = new Cesium.GeometryInstance({
                geometry : new Cesium.PolygonGeometry({
                  polygonHierarchy : new Cesium.PolygonHierarchy(Cesium.Cartesian3.fromDegreesArrayHeights(temp_poly)),
                  perPositionHeight: true,
                }),
                attributes : {
                  color :  Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.ORANGE.withAlpha(0.3))
                }
              });
              poly_list.push(temp_instance);
            }
          }
          typhoon_poly = new Cesium.Primitive({
            id : name_list[i],
            geometryInstances : poly_list,
            appearance : new Cesium.PerInstanceColorAppearance({

            })
          });
          typhoonCollection.add(typhoon_poly);
          console.log(typhoon_poly);
        }

      } else {
        gl_p_data = p_data;
        for (var i = 0; i < gl_p_data.features.length; i++) {
          one_ty = new Array();
          var p_geo = gl_p_data.features[i].temporalGeometry; //one typhoon
          for (var k = 0; k < 9; k++) { //lines
            new_line = new Array();
            for (var j = 0; j < p_geo.coordinates.length; j++) {
              new_point = new Array();
              new_point.push(p_geo.coordinates[j][k][0]);
              new_point.push(p_geo.coordinates[j][k][1]);
              new_line.push(new_point);
            }
            one_ty.push(new_line);
          }
          p_ty.push(one_ty);
        }
        var poly_list;
        var typhoon_poly;
        for (var i = 0; i < name_list.length; i++) { // one typ
          poly_list = new Array();
          for (var j = 0; j < 8; j++) { //line searching with 2
            for (var k = 0; k < p_ty[i][j].length - 1; k++) { //the number of poly in one typhoon
              var temp_poly = new Array();
              var first = p_ty[i][j][k];
              var sec = p_ty[i][j + 1][k];
              var third = p_ty[i][j + 1][k + 1];
              var forth = p_ty[i][j][k + 1];
              temp_poly.push(first[0], first[1], sec[0], sec[1], third[0], third[1], forth[0], forth[1]);

              var temp_instance = new Cesium.GeometryInstance({
                geometry : new Cesium.PolygonGeometry({
                  polygonHierarchy : new Cesium.PolygonHierarchy(Cesium.Cartesian3.fromDegreesArray(temp_poly)),
                  perPositionHeight : true
                }),
                attributes : {
                  color :  Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.ORANGE.withAlpha(0.3))
                }
              });
              poly_list.push(temp_instance);
        }

          }
          typhoon_poly = new Cesium.Primitive({
            id : name_list[i],
            geometryInstances : poly_list,
            appearance : new Cesium.PerInstanceColorAppearance()
          });
          typhoonCollection.add(typhoon_poly);
        }
      }
      //viewer.scene.primitives.add(typhoonCollection);

    });
  }
  function poly_change(filename, polyCollection) {
    var gl_p_data;
    var name_list = [];
    polyCollection.removeAll();
    $.getJSON(filename, function(p_data) {
      gl_p_data = p_data;
      for (var i = 0; i < gl_p_data.features.length; i++) {
        name_list.push(gl_p_data.features[i].properties.name);
      }
      var p_ty = [];
      for (var i = 0; i < gl_p_data.features.length; i++) {
        var one_ty = new Array();
        var p_geo = gl_p_data.features[i].temporalGeometry; //one typhoon
        for (var k = 0; k < 9; k++) { //lines
          new_line = new Array();
          for (var j = 0; j < p_geo.coordinates.length; j++) {
            new_point = new Array();
            new_point.push(p_geo.coordinates[j][k][0]);
            new_point.push(p_geo.coordinates[j][k][1]);
            new_line.push(new_point);
          }
          one_ty.push(new_line);
        }
        p_ty.push(one_ty);
      }
      var poly_list;
      var typhoon_poly;
      for (var i = 0; i < name_list.length; i++) { // one typ
        poly_list = new Array();
        for (var j = 0; j < 8; j++) { //line searching with 2
          for (var k = 0; k < p_ty[i][j].length - 1; k++) {
            var temp_poly = new Array();
            var first = p_ty[i][j][k];
            var sec = p_ty[i][j + 1][k];
            var third = p_ty[i][j + 1][k + 1];
            var forth = p_ty[i][j][k + 1];
            temp_poly.push(first[0], first[1], sec[0], sec[1], third[0], third[1], forth[0], forth[1]);
            var temp_instance = new Cesium.GeometryInstance({
              geometry : new Cesium.PolygonGeometry({
                polygonHierarchy : new Cesium.PolygonHierarchy(Cesium.Cartesian3.fromDegreesArray(temp_poly)),
                perPositionHeight: true,
              }),
              attributes : {
                color :  Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.ORANGE.withAlpha(0.3))
              }
            });
            poly_list.push(temp_instance);
          }
        }
        typhoon_poly = new Cesium.Primitive({
          id : name_list[i],
          geometryInstances : poly_list,
          appearance : new Cesium.PerInstanceColorAppearance()
        });
        polyCollection.add(typhoon_poly);
      }
      //scene.primitives.add(polyCollection);
    });

  }
  var czml_poly = [];
function setDefaultClock(){
  var start = Cesium.JulianDate.fromDate(new Date());
  var end = Cesium.JulianDate.addDays(start, 1, new Cesium.JulianDate());
  viewer.clock.startTime = start.clone();
  viewer.clock.stopTime = end.clone();
  viewer.clock.currentTime = start.clone();
  viewer.clock.multiplier = 1;
  viewer.timeline.zoomTo(start, end);
}
  function getMovingPolygon(radioItem, filename){
    var filename_name = filename.toString();
    filename_name = filename_name.split(".")[0];
    var id = filename_name + radioItem.toString();

     $.getJSON(filename, function(p_data){
        if(contains(selected_poly_radio,id)){
          var already_selected = selected_poly_radio.indexOf(id);
          selected_poly_radio.splice(already_selected, 1);
          viewer.dataSources.removeAll();
          setDefaultClock();
        }
        else{

          selected_poly_radio.push(id);
          var gl_p_data = p_data;
          var one_ty = new Array();
          var timeline = new Array();
          var p_geo = gl_p_data.features[radioItem].temporalGeometry; //one typhoon
          var base = getTime2(p_geo.datetimes[0]);

          for(var j = 0 ; j < p_geo.coordinates.length; j++){
            var one_poly = new Array();
            for(var k = 0 ; k < 9 ; k++){
              var one_point = new Array();
              one_point.push(p_geo.coordinates[j][k][0]);
              one_point.push(p_geo.coordinates[j][k][1]);
              if(scene.mode == Cesium.SceneMode.COLUMBUS_VIEW){
                one_point.push((getTime2(p_geo.datetimes[j])-base)*3/1000);
              }
              else {
                one_point.push(0);
              }
              one_poly.push(one_point);
            }
            one_ty.push(one_poly);
          }
          var ty_new_point = new Array();//get the polygon points for drawing interpolating.

        for(var i = 0 ; i < one_ty.length ; i++){

            ty_new_point.push(one_ty[i]);

            var base = getTime2(p_geo.datetimes[i]);   //to change string time to javascript Date time
            timeline.push(base.toISOString());

          }
          czml_poly = [];
          var new_czml_poly = {};
          var color_info = {};
          var availability = timeline[0].toString();
          availability += "/";
          availability += timeline[timeline.length-1].toString();

          new_czml_poly.id = "document";
          new_czml_poly.version = "1.0";
          new_czml_poly.name = "CZML polygon";

          czml_poly.push(new_czml_poly);
          new_czml_poly = {};
          new_czml_poly.id = "dynamicPolygon";
          new_czml_poly.availability = availability;
          new_czml_poly.polygon = {};

          new_czml_poly.polygon.positions = {};
          new_czml_poly.polygon.positions.references = [];
          new_czml_poly.polygon.perPositionHeight = true;
          new_czml_poly.polygon.material = {};
          new_czml_poly.polygon.material.solidColor = {};
          new_czml_poly.polygon.material.solidColor.color = [];
          new_czml_poly.polygon.positions.references = new Array();

          color_info.interval = availability;
          color_info.rgbaf = [1, 0, 1, 1];
          new_czml_poly.polygon.material.solidColor.color.push(color_info);
          czml_poly.push(new_czml_poly);



          for(var j = 0 ; j < 8 ; j++){
            new_czml_poly = {};
            new_czml_poly.id = "polygons" + j.toString();
            new_czml_poly.position = {};
            new_czml_poly.position.interval = availability;
            new_czml_poly.position.epoch = timeline[0];
            new_czml_poly.position.cartographicDegrees = [];
            new_czml_poly.position.interpolationAlgorithm = "LINEAR";
            new_czml_poly.position.interpolationDegree = 1;

            for(var i = 0 ; i < ty_new_point.length; i++){

              new_czml_poly.position.cartographicDegrees.push(timeline[i]);
              new_czml_poly.position.cartographicDegrees.push(ty_new_point[i][j][0],ty_new_point[i][j][1],ty_new_point[i][j][2]);

            }
            czml_poly.push(new_czml_poly);
          }
          czml_poly[1].polygon.positions.references = [];
          for(var i = 0 ; i < 8 ; i++){
            var temp_id = "polygons" + i.toString();
            czml_poly[1].polygon.positions.references.push(temp_id+"#position");
          }

          viewer.dataSources.add(Cesium.CzmlDataSource.load(czml_poly));
          console.log(viewer.dataSources);


        }
     });


  }
  function getTime2(timevalue){
    var time = timevalue; //the basetime we will use for nomalization of datetimes
    var time_split = time.split(' '); //get date
    var date_arr = time_split[0].split('-');
    var time_arr = time_split[1].split(':');
    var timestamp = new Date(date_arr[0], date_arr[1] - 1, date_arr[2], time_arr[0], time_arr[1], time_arr[2]);
    return timestamp;
  }
  function poly_change_COL(filename, polyCollection) {
    polyCollection.removeAll();
    $.getJSON(filename, function(p_data) {
      var p_ty = [];
      var gl_p_data = p_data;
      var name_list = [];
      for (var i = 0; i < gl_p_data.features.length; i++) {
        name_list.push(gl_p_data.features[i].properties.name);
      }

      p_ty = [];

      for (var i = 0; i < gl_p_data.features.length; i++) {
        one_ty = new Array();
        var p_geo = gl_p_data.features[i].temporalGeometry; //one typhoon
        var base = p_geo.datetimes[0].split(" ");
        var base_J = Cesium.JulianDate.fromIso8601(base[0] + "T" + base[1] + "Z");
        for (var k = 0; k < 9; k++) { //lines
          new_line = new Array();
          for (var j = 0; j < p_geo.coordinates.length; j++) {
            new_point = new Array();
            var temp_time = p_geo.datetimes[j].split(" ");
            var temp_time_J = Cesium.JulianDate.fromIso8601(temp_time[0] + "T" + temp_time[1] + "Z");
            new_point.push(p_geo.coordinates[j][k][0]);
            new_point.push(p_geo.coordinates[j][k][1]);
            new_point.push(Cesium.JulianDate.secondsDifference(temp_time_J, base_J) * 3);
            new_line.push(new_point);
          }
          one_ty.push(new_line);
        }
        p_ty.push(one_ty);

      }
      var poly_list;
      var typhoon_poly;
      for (var i = 0; i < name_list.length; i++) { // one typ
        poly_list = new Array();

        for (var j = 0; j < 8; j++) { //line searching with 2

          for (var k = 0; k < p_ty[i][j].length - 1; k++) {
            var temp_poly = new Array();
            var first = p_ty[i][j][k];
            var sec = p_ty[i][j + 1][k];
            var third = p_ty[i][j + 1][k + 1];
            var forth = p_ty[i][j][k + 1];
            temp_poly.push(first[0], first[1], first[2], sec[0], sec[1], sec[2], third[0], third[1], third[2], forth[0], forth[1], forth[2]);

            var temp_instance = new Cesium.GeometryInstance({
              geometry : new Cesium.PolygonGeometry({
                polygonHierarchy : new Cesium.PolygonHierarchy(Cesium.Cartesian3.fromDegreesArrayHeights(temp_poly)),

                perPositionHeight: true,
              }),
              attributes : {
                color :  Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA.withAlpha(0.3))
              }
            });
            poly_list.push(temp_instance);
          }

        }
        typhoon_poly = new Cesium.Primitive({
          id : name_list[i],
          geometryInstances : poly_list,
          appearance : new Cesium.PerInstanceColorAppearance()
        });
        polyCollection.add(typhoon_poly);
      }
      scene.primitives.add(polyCollection);
    });

  }

function getSurface(filename){

  var s_data;
  var triangle_list = new Array();
  var poly_primitive = new Cesium.Primitive();
  var geo_list = new Array();
  var triangleCollection = new Cesium.PrimitiveCollection();
  $.getJSON(filename,function(data){
    s_data = data;
    for(var i = 0 ; i < s_data.features.length-1 ; i++){//get the trianglepoints
      var coordinates_list1 = s_data.features[i].temporalGeometry.coordinates;
      var timeline_list1 = s_data.features[i].temporalGeometry.datetimes;
      var coordinates_list2 = s_data.features[i+1].temporalGeometry.coordinates;
      var timeline_list2 = s_data.features[i+1].temporalGeometry.datetimes;
      coordinates_list1 = get3DPoints(coordinates_list1,timeline_list1);
      coordinates_list2 = get3DPoints(coordinates_list2,timeline_list2);

    //  triangle_list.push(calculateSurface(coordinates_list1[0], coordinates_list2[0]));
      triangle_list.push(calculateSurface(coordinates_list1[0], coordinates_list2[7]));
    }

    var temp_poly = [];
    for(var i = 0 ; i < triangle_list.length ; i++){//put the points into one array for make geoMetryInstance per one triangle

      for(var j = 0 ; j < triangle_list[i].length ; j++){
        for(var k = 0 ; k < triangle_list[i][j].length ; k++){
          temp_poly.push(triangle_list[i][j][k][0],triangle_list[i][j][k][1],triangle_list[i][j][k][2]);
        }

      var triangles = new Cesium.GeometryInstance({ //one triangle
        geometry : new Cesium.PolygonGeometry({
          polygonHierarchy : new Cesium.PolygonHierarchy(Cesium.Cartesian3.fromDegreesArrayHeights(temp_poly)),
          perPositionHeight : true
        }),
        attributes : {
          color :  Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromRandom().withAlpha(0.5))
        }
      });
      geo_list.push(triangles);//later, we will put this into new Primitive variable
      temp_poly = [];
    }
    }
    poly_primitive = new Cesium.Primitive({
      geometryInstances : geo_list,
      appearance : new Cesium.PerInstanceColorAppearance()
    });
    viewer.scene.primitives.add(poly_primitive);
  });
}
function get3DPoints(coordinates,timeline){
  var base = getTime2(timeline[0]);
  var temp_point = new Array();
  var temp_list = new Array();
  var poly_lines = new Array();
  for(var i = 0 ; i < coordinates.length ; i++){
    for(var j = 0 ; j < coordinates[i].length; j++){
      temp_point.push(coordinates[i][j][0],coordinates[i][j][1]);
      temp_point.push((getTime2(timeline[i])-base)*7/1000);
      temp_list.push(temp_point);
      temp_point = [];
    }
    poly_lines.push(temp_list);
    temp_list = [];
  }
  return poly_lines;
}

function calculateSurface(polyline1,polyline2){
  var surface = new Array();

  for(var i = 0 ; i < polyline1.length-1 ; i++){
    var distance = 100000000;
    var nearestSet = new Array();
      for(var j = 0 ; j < polyline2.length ; j++){
        if(distance > calculateDistanceThree3D(polyline1[i],polyline1[i+1],polyline2[j])){
          distance = calculateDistanceThree3D(polyline1[i],polyline1[i+1],polyline2[j]);
          nearestSet = [];
          nearestSet.push(polyline1[i],polyline1[i+1],polyline2[j]);
        }
      }

    surface.push(nearestSet);
  }
  for(var i = 0 ; i < polyline2.length-1 ; i++){
    var distance = 100000000;
    var nearestSet = new Array();
      for(var j = 0 ; j < polyline1.length ; j++){
        if(distance > calculateDistanceThree3D(polyline2[i],polyline2[i+1],polyline1[j])){
          distance = calculateDistanceThree3D(polyline2[i],polyline2[i+1],polyline1[j]);
          nearestSet = [];
          nearestSet.push(polyline2[i],polyline2[i+1],polyline1[j]);
        }
      }

    surface.push(nearestSet);
  }

  return surface;
}
  function euclidianDistance3D(a, b){
    var pow1 = Math.pow(a[0]-b[0],2);
    var pow2 = Math.pow(a[1]-b[1],2);
    var pow3 = Math.pow(a[2]-b[2],2);
    return Math.sqrt(pow1 + pow2 + pow3);
  }
function calculateDistanceThree3D(p1, p2, p3){
  var dis1 = euclidianDistance3D(p1,p3);
  var dis2 = euclidianDistance3D(p2,p3);
  return dis1+dis2;
}
function getMovingUnsamePolygon(filename){
  var s_data;
  var triangle_list = new Array();
  var poly_primitive = new Cesium.Primitive();
  var geo_list = new Array();
  var triangleCollection = new Cesium.PrimitiveCollection();
  $.getJSON(filename,function(data){
    s_data = data;

    for(var i = 0 ; i < s_data.features.length-1 ; i++){//get the trianglepoints
      var coordinates_list1 = s_data.features[i].temporalGeometry.coordinates;
      var timeline_list1 = s_data.features[i].temporalGeometry.datetimes;
      var coordinates_list2 = s_data.features[i+1].temporalGeometry.coordinates;
      var timeline_list2 = s_data.features[i+1].temporalGeometry.datetimes;
      coordinates_list1 = get3DPoints(coordinates_list1,timeline_list1);
      coordinates_list2 = get3DPoints(coordinates_list2,timeline_list2);
      getMovingLineString(coordinates_list1[0],getTime2(timeline_list2[0]).toISOString(),coordinates_list1[1],getTime2(timeline_list1[1]).toISOString());
    }
  });
};
function getMovingLineString(polyline1,timeline,polyline2,timeline2){ //in advanced, we put 3D points to this function.
  var longer;
  var shorter;
  var point_list = new Array();

  if(polyline1.length >= polyline2.length){
    longer = polyline1;
    shorter = polyline2;
  }
  else{
    longer = polyline2;
    shorter = polyline1;
  }

  for(var i = 0 ; i < longer.length ; i++){
    var distance = 1000000000;
    var temp_list = [];
    for(var j = 0 ; j < shorter.length ; j++){

      if(distance > euclidianDistance3D(longer[i],shorter[j])){
        temp_list = [];

        distance = euclidianDistance3D(longer[i],shorter[j]);
        if(scene.mode !== Cesium.SceneMode.COLUMBUS_VIEW){
          longer[i][2] = 0;
          shorter[j][2] = 0;
        }
        temp_list.push(longer[i],shorter[j]);

      }
    }
    point_list.push(temp_list);
  }
  var czml_poly = [];
  var new_czml_poly = {};
  var color_info = {};
  var availability = timeline.toString();
  availability += "/";
  availability += timeline2.toString();

  new_czml_poly.id = "document";
  new_czml_poly.version = "1.0";
  new_czml_poly.name = "CZML polygon";

  czml_poly.push(new_czml_poly);
  new_czml_poly = {};
  new_czml_poly.id = "dynamicLineString";
  new_czml_poly.availability = availability;
  new_czml_poly.polygon = {};

  new_czml_poly.polygon.positions = {};
  new_czml_poly.polygon.positions.references = [];
  new_czml_poly.polygon.perPositionHeight = true;
  new_czml_poly.polygon.material = {};
  new_czml_poly.polygon.material.solidColor = {};
  new_czml_poly.polygon.material.solidColor.color = [];
  new_czml_poly.polygon.positions.references = new Array();

  color_info.interval = availability;
  color_info.rgbaf = [1, 0, 1, 1];
  new_czml_poly.polygon.material.solidColor.color.push(color_info);
  czml_poly.push(new_czml_poly);

  for(var j = 0 ; j < point_list.length ; j++){
    new_czml_poly = {};
    new_czml_poly.id = "lineStrings" + j.toString();
    new_czml_poly.position = {};
    new_czml_poly.position.interval = availability;
    new_czml_poly.position.epoch = timeline;
    new_czml_poly.position.cartographicDegrees = [];
    new_czml_poly.position.interpolationAlgorithm = "LINEAR";
    new_czml_poly.position.interpolationDegree = 1;
    new_czml_poly.position.cartographicDegrees.push(timeline);
    new_czml_poly.position.cartographicDegrees.push(point_list[j][0][0],point_list[j][0][1],point_list[j][0][2]);
    new_czml_poly.position.cartographicDegrees.push(timeline2);
    new_czml_poly.position.cartographicDegrees.push(point_list[j][1][0],point_list[j][1][1],point_list[j][1][2]);
    console.log(new_czml_poly);
    czml_poly.push(new_czml_poly);
  }



  czml_poly[1].polygon.positions.references = [];
  for(var i = 0 ; i < point_list.length ; i++){
    var temp_id = "lineStrings" + i.toString();
    czml_poly[1].polygon.positions.references.push(temp_id+"#position");
  }
  console.log(czml_poly);
  var result = Cesium.CzmlDataSource.load(czml_poly);
  console.log(Cesium.CzmlDataSource.load(czml_poly));
  var result2 = viewer.dataSources.add(result);
  console.log(result2);
  console.log(viewer.dataSources);

}


function get2Dpoints(coordinates){
  var temp_point = new Array();
  var temp_list = new Array();
  var poly_lines = new Array();
  for(var i = 0 ; i < coordinates.length ; i++){
    for(var j = 0 ; j < coordinates[i].length; j++){
      temp_point.push(coordinates[i][j][0],coordinates[i][j][1]);
      temp_list.push(temp_point);
      temp_point = [];
    }
    poly_lines.push(temp_list);
    temp_list = [];
  }
  return poly_lines;
}

function euclidianDistance2D(a, b){
  var pow1 = Math.pow(a[0]-b[0],2);
  var pow2 = Math.pow(a[1]-b[1],2);
  return Math.sqrt(pow1 + pow2);
}

  </script>

</body>

</html>
